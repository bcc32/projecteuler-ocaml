open! Core
open! Import

let%test_module "naive solution" =
  (module struct
    let is_hamming n =
      let rec loop k n = if n mod k = 0 then loop k (n / k) else n in
      n |> loop 2 |> loop 3 |> loop 5 |> ( = ) 1
    ;;

    let s_naive l ~modulo =
      Sequence.range 1 l ~stop:`inclusive
      |> Sequence.filter ~f:(fun n -> Number_theory.Int.totient n |> is_hamming)
      |> Sequence.sum
           ~f:Fn.id
           (module struct
             type t = int [@@deriving sexp]

             let zero = 0
             let ( + ) a b = (a + b) mod modulo
             let ( - ) a b = (a - b) mod modulo
           end)
    ;;

    let%expect_test _ =
      print_s [%sexp (s_naive 100 ~modulo:(1 lsl 32) : int)];
      [%expect {| 3728 |}]
    ;;
  end)
;;

(* TODO move this to Euler *)
module Stream : sig
  type 'a t = 'a node Lazy.t

  and 'a node =
    | Nil
    | Cons of 'a * 'a t

  include Container.S1 with type 'a t := 'a t
  include Monad.S with type 'a t := 'a t

  (** [merge_and_dedup a b ~compare] returns a sorted union of the elements of
      [a] and [b], which must be increasing sequences. *)
  val merge_and_dedup : 'a t -> 'a t -> compare:('a -> 'a -> int) -> 'a t
end = struct
  module T = struct
    type 'a t = 'a node Lazy.t

    and 'a node =
      | Nil
      | Cons of 'a * 'a t

    let empty = Lazy.from_val Nil
  end

  include T

  include Container.Make (struct
      include T

      let rec fold t ~init ~f =
        match force t with
        | Nil -> init
        | Cons (hd, tl) -> fold tl ~init:(f init hd) ~f
      ;;

      let rec iter t ~f =
        match force t with
        | Nil -> ()
        | Cons (hd, tl) ->
          f hd;
          iter tl ~f
      ;;

      let iter = `Custom iter
      let length = `Define_using_fold
    end)

  let rec append (t1 : 'a t) (t2 : 'a t) : 'a t =
    lazy
      (match force t1 with
       | Nil -> force t2
       | Cons (hd, tl) -> Cons (hd, append tl t2))
  ;;

  let rec map t ~f =
    lazy
      (match force t with
       | Nil -> Nil
       | Cons (hd, tl) -> Cons (f hd, map tl ~f))
  ;;

  include Monad.Make (struct
      include T

      let return x = Lazy.from_val (Cons (x, empty))

      let rec bind t ~f =
        lazy
          (match force t with
           | Nil -> Nil
           | Cons (hd, tl) -> force (append (f hd) (bind tl ~f)))
      ;;

      let map = `Custom map
    end)

  let rec merge_and_dedup t1 t2 ~compare =
    lazy
      (match t1, t2 with
       | (lazy Nil), _ -> force t2
       | _, (lazy Nil) -> force t1
       | (lazy (Cons (hd1, tl1))), (lazy (Cons (hd2, _)))
         when compare hd1 hd2 < 0 -> Cons (hd1, merge_and_dedup tl1 t2 ~compare)
       | (lazy (Cons (hd1, tl1))), (lazy (Cons (hd2, tl2)))
         when compare hd1 hd2 = 0 -> Cons (hd1, merge_and_dedup tl1 tl2 ~compare)
       | (lazy (Cons _)), (lazy (Cons (hd2, tl2))) ->
         Cons (hd2, merge_and_dedup t1 tl2 ~compare))
  ;;
end

let hamming =
  let rec seq =
    lazy
      (let two = Stream.map seq ~f:(fun x -> x * 2) in
       let three = Stream.map seq ~f:(fun x -> x * 3) in
       let five = Stream.map seq ~f:(fun x -> x * 5) in
       let merge_and_dedup = Stream.merge_and_dedup ~compare:Int.compare in
       Cons (1, merge_and_dedup (merge_and_dedup two three) five))
  in
  seq
;;

let%test_module _ =
  (module struct
    let%expect_test _ =
      let count = ref 0 in
      try
        hamming
        |> Stream.iter ~f:(fun x ->
          if x > 1_000_000_000_000 then raise Exit;
          incr count);
        assert false (* TODO replace with [%expect.unreachable] when available *)
      with
      | Exit ->
        print_s [%message "" ~total_hamming_numbers:(!count : int)];
        [%expect {|
        (total_hamming_numbers 3429) |}]
    ;;
  end)
;;

(* phi(n) = Pi phi(p^k) is a Hamming number iff each of phi(p^k) is a Hamming
   number.

   phi(p_i^k_i) = p_i^(k_i-1)(p_i - 1).

   Find out which phi(p^k) are Hamming numbers... there are only about (log(2,
   1e12) * log(3, 1e12) * log(5, 1e12) / 6 ~~ 2869) Hamming numbers below 1e12
   (consider the inequality (x / log(2, 1e12) + y / log(3, 1e12) + z / log(5,
   1e12) <= 1e12), whose solution is a pyramidal region with a triangular base
   in plane xy (triangle with base log(2, 1e12) height log(3, 1e12)) and height
   log(5, 1e12)).

   Pick all prime powers with k >= 2 (not so many, considering log(2, 1e12) is
   about 40), and intersect with the set of Hamming numbers below 1e12.

   To pick prime powers with k = 1, just add one to each Hamming number and
   check for primality.

   Once we have all the prime powers with Hamming-number totients, we can simply
   combine all of them to get all n with Hamming-number totients. *)

let prime_powers_with_hamming_totient ~upto =
  let hamming_set =
    hamming
    |> Stream.fold_until ~init:[] ~finish:Fn.id ~f:(fun ac x ->
      if x <= upto then Continue (x :: ac) else Stop ac)
    |> Array.of_list
    |> Int.Set.of_sorted_array_unchecked
  in
  let powers =
    Hash_set.create
      (module struct
        include Tuple.Make (Int) (Int)
        include Tuple.Hashable (Int) (Int)
      end)
      ()
  in
  let is_prime = Number_theory.prime_sieve (Number_theory.Int.isqrt upto) in
  for i = 2 to Array.length is_prime - 1 do
    if is_prime.(i)
    then (
      let rec loop k pk =
        if pk <= upto
        then (
          if Set.mem hamming_set pk then Hash_set.add powers (i, k);
          loop (k + 1) (pk * i))
        else ()
      in
      loop 2 (i * i))
  done;
  hamming_set
  |> Set.iter ~f:(fun x ->
    if Number_theory.Int.is_prime (x + 1) then Hash_set.add powers (x + 1, 1));
  powers
;;

let%expect_test _ =
  print_s
    [%sexp
      (prime_powers_with_hamming_totient ~upto:1_000_000_000_000 : (int * int) Hash_set.t)];
  [%expect
    {|
    ((2 1) (2 2) (2 3) (2 4) (2 5) (2 6) (2 7) (2 8) (2 9) (2 10) (2 11)
     (2 12) (2 13) (2 14) (2 15) (2 16) (2 17) (2 18) (2 19) (2 20) (2 21)
     (2 22) (2 23) (2 24) (2 25) (2 26) (2 27) (2 28) (2 29) (2 30) (2 31)
     (2 32) (2 33) (2 34) (2 35) (2 36) (2 37) (2 38) (2 39) (3 1) (3 2)
     (3 3) (3 4) (3 5) (3 6) (3 7) (3 8) (3 9) (3 10) (3 11) (3 12) (3 13)
     (3 14) (3 15) (3 16) (3 17) (3 18) (3 19) (3 20) (3 21) (3 22) (3 23)
     (3 24) (3 25) (5 1) (5 2) (5 3) (5 4) (5 5) (5 6) (5 7) (5 8) (5 9)
     (5 10) (5 11) (5 12) (5 13) (5 14) (5 15) (5 16) (5 17) (7 1) (11 1)
     (13 1) (17 1) (19 1) (31 1) (37 1) (41 1) (61 1) (73 1) (97 1) (101 1)
     (109 1) (151 1) (163 1) (181 1) (193 1) (241 1) (251 1) (257 1) (271 1)
     (401 1) (433 1) (487 1) (541 1) (577 1) (601 1) (641 1) (751 1) (769 1)
     (811 1) (1153 1) (1201 1) (1297 1) (1459 1) (1601 1) (1621 1) (1801 1)
     (2161 1) (2251 1) (2593 1) (2917 1) (3001 1) (3457 1) (3889 1) (4001 1)
     (4051 1) (4801 1) (4861 1) (6481 1) (7681 1) (8101 1) (8641 1) (9001 1)
     (9601 1) (9721 1) (10369 1) (11251 1) (12289 1) (14401 1) (15361 1)
     (16001 1) (17497 1) (18433 1) (19441 1) (21601 1) (21871 1) (22501 1)
     (23041 1) (24001 1) (25601 1) (32401 1) (33751 1) (36451 1) (37501 1)
     (39367 1) (40961 1) (43201 1) (52489 1) (54001 1) (57601 1) (58321 1)
     (61441 1) (62501 1) (65537 1) (72901 1) (76801 1) (77761 1) (81001 1)
     (87481 1) (90001 1) (96001 1) (103681 1) (112501 1) (115201 1) (121501 1)
     (131221 1) (138241 1) (139969 1) (147457 1) (150001 1) (155521 1) (160001 1)
     (163841 1) (172801 1) (180001 1) (184321 1) (196831 1) (209953 1) (259201 1)
     (270001 1) (281251 1) (307201 1) (311041 1) (328051 1) (331777 1) (345601 1)
     (384001 1) (405001 1) (414721 1) (432001 1) (437401 1) (450001 1) (466561 1)
     (472393 1) (506251 1) (562501 1) (576001 1) (629857 1) (737281 1) (746497 1)
     (786433 1) (839809 1) (900001 1) (921601 1) (937501 1) (972001 1) (995329 1)
     (1125001 1) (1166401 1) (1179649 1) (1350001 1) (1492993 1) (1620001 1)
     (1769473 1) (1822501 1) (1843201 1) (1920001 1) (1968301 1) (1990657 1)
     (2073601 1) (2099521 1) (2160001 1) (2400001 1) (2654209 1) (2799361 1)
     (3037501 1) (3072001 1) (3456001 1) (3600001 1) (3686401 1) (3750001 1)
     (4218751 1) (4374001 1) (4423681 1) (4723921 1) (5038849 1) (5184001 1)
     (5308417 1) (5314411 1) (5400001 1) (5904901 1) (6144001 1) (6561001 1)
     (6635521 1) (6750001 1) (6998401 1) (7290001 1) (8201251 1) (8503057 1)
     (8640001 1) (8748001 1) (9375001 1) (10125001 1) (10497601 1) (11059201 1)
     (11337409 1) (12150001 1) (12441601 1) (12597121 1) (12656251 1)
     (13122001 1) (13668751 1) (14155777 1) (15552001 1) (16384001 1)
     (16588801 1) (16796161 1) (17496001 1) (17714701 1) (18750001 1)
     (19131877 1) (20995201 1) (21600001 1) (22118401 1) (24000001 1)
     (24576001 1) (25312501 1) (26214401 1) (27993601 1) (28125001 1)
     (28311553 1) (28800001 1) (29524501 1) (30000001 1) (30375001 1)
     (31492801 1) (33177601 1) (35389441 1) (40960001 1) (41990401 1)
     (48600001 1) (49152001 1) (54675001 1) (55987201 1) (57395629 1)
     (62500001 1) (63700993 1) (65610001 1) (71663617 1) (73811251 1)
     (76800001 1) (81000001 1) (82012501 1) (83980801 1) (86093443 1)
     (88573501 1) (92160001 1) (93312001 1) (99532801 1) (101250001 1)
     (102036673 1) (104857601 1) (105468751 1) (113246209 1) (113906251 1)
     (117964801 1) (120932353 1) (124416001 1) (129600001 1) (132710401 1)
     (141557761 1) (144000001 1) (145800001 1) (149299201 1) (150000001 1)
     (162000001 1) (167772161 1) (169869313 1) (170061121 1) (175781251 1)
     (177147001 1) (179159041 1) (189843751 1) (212576401 1) (226748161 1)
     (238878721 1) (245760001 1) (253125001 1) (256000001 1) (258280327 1)
     (265420801 1) (265720501 1) (273375001 1) (281250001 1) (288000001 1)
     (307200001 1) (331776001 1) (377487361 1) (409600001 1) (410062501 1)
     (414720001 1) (432000001 1) (460800001 1) (466560001 1) (468750001 1)
     (478296901 1) (483729409 1) (573956281 1) (600000001 1) (614400001 1)
     (615093751 1) (637009921 1) (637729201 1) (655360001 1) (725594113 1)
     (746496001 1) (754974721 1) (786432001 1) (860934421 1) (864000001 1)
     (874800001 1) (885735001 1) (937500001 1) (943718401 1) (956593801 1)
     (984150001 1) (1036800001 1) (1049760001 1) (1088391169 1) (1119744001 1)
     (1125000001 1) (1133740801 1) (1194393601 1) (1399680001 1) (1415577601 1)
     (1492992001 1) (1500000001 1) (1536000001 1) (1572864001 1) (1749600001 1)
     (1811939329 1) (1843200001 1) (1889568001 1) (2013265921 1) (2187000001 1)
     (2239488001 1) (2304000001 1) (2361960001 1) (2441406251 1) (2500000001 1)
     (2519424001 1) (2717908993 1) (2869781401 1) (2916000001 1) (2949120001 1)
     (2952450001 1) (3110400001 1) (3164062501 1) (3221225473 1) (3224862721 1)
     (3280500001 1) (3439853569 1) (3587226751 1) (3645000001 1) (3796875001 1)
     (3874204891 1) (3936600001 1) (4050000001 1) (4076863489 1) (4194304001 1)
     (4218750001 1) (4687500001 1) (4782969001 1) (4915200001 1) (5125781251 1)
     (5165606521 1) (5273437501 1) (5535843751 1) (5898240001 1) (6000000001 1)
     (6298560001 1) (6561000001 1) (6802444801 1) (6834375001 1) (6879707137 1)
     (6912000001 1) (7962624001 1) (8162933761 1) (8542968751 1) (8789062501 1)
     (9000000001 1) (9331200001 1) (9375000001 1) (9447840001 1) (9600000001 1)
     (10485760001 1) (10616832001 1) (10871635969 1) (11466178561 1)
     (11609505793 1) (11664000001 1) (11943936001 1) (13183593751 1)
     (13604889601 1) (13996800001 1) (14155776001 1) (14400000001 1)
     (14511882241 1) (14929920001 1) (15305500801 1) (15496819561 1)
     (16384000001 1) (16875000001 1) (17006112001 1) (17714700001 1)
     (17915904001 1) (18000000001 1) (18345885697 1) (18874368001 1)
     (18984375001 1) (20384317441 1) (20407334401 1) (20503125001 1)
     (21523360501 1) (22781250001 1) (22958251201 1) (23245229341 1)
     (23437500001 1) (23619600001 1) (23914845001 1) (24159191041 1)
     (24300000001 1) (25165824001 1) (25312500001 1) (26873856001 1)
     (28697814001 1) (29386561537 1) (30000000001 1) (30720000001 1)
     (30754687501 1) (32285040751 1) (32651735041 1) (33215062501 1)
     (33973862401 1) (34560000001 1) (36450000001 1) (36864000001 1)
     (38220595201 1) (39550781251 1) (41472000001 1) (42515280001 1)
     (42998169601 1) (43945312501 1) (45298483201 1) (45562500001 1)
     (47775744001 1) (47829690001 1) (48000000001 1) (48372940801 1)
     (51840000001 1) (55099802881 1) (56953125001 1) (63700992001 1)
     (64497254401 1) (66355200001 1) (69657034753 1) (69984000001 1)
     (74649600001 1) (75000000001 1) (76441190401 1) (76800000001 1)
     (77309411329 1) (82012500001 1) (85030560001 1) (85996339201 1)
     (87890625001 1) (88473600001 1) (91729428481 1) (94371840001 1)
     (96855122251 1) (97656250001 1) (105468750001 1) (116095057921 1)
     (117964800001 1) (122305904641 1) (123834728449 1) (129600000001 1)
     (132710400001 1) (137749507201 1) (138240000001 1) (140625000001 1)
     (141717600001 1) (144955146241 1) (151875000001 1) (153773437501 1)
     (154968195601 1) (163258675201 1) (165888000001 1) (169869312001 1)
     (171992678401 1) (174339220051 1) (174960000001 1) (177147000001 1)
     (183458856961 1) (187500000001 1) (191318760001 1) (194400000001 1)
     (206158430209 1) (209952000001 1) (213574218751 1) (226492416001 1)
     (235929600001 1) (251048476873 1) (269042006251 1) (276480000001 1)
     (289910292481 1) (292968750001 1) (294912000001 1) (306110016001 1)
     (309586821121 1) (311040000001 1) (313810596091 1) (314928000001 1)
     (337500000001 1) (344373768001 1) (347892350977 1) (384000000001 1)
     (390625000001 1) (402653184001 1) (407686348801 1) (409600000001 1)
     (424673280001 1) (425152800001 1) (430467210001 1) (447897600001 1)
     (461320312501 1) (464904586801 1) (466560000001 1) (474609375001 1)
     (498225937501 1) (512578125001 1) (549316406251 1) (562500000001 1)
     (573308928001 1) (576000000001 1) (580475289601 1) (619872782401 1)
     (679477248001 1) (711914062501 1) (716636160001 1) (720000000001 1)
     (816293376001 1) (820125000001 1) (825564856321 1) (829440000001 1)
     (836828256241 1) (864000000001 1) (871696100251 1) (880602513409 1)
     (922640625001 1) (966367641601 1) (967458816001 1)) |}]
;;

let arrange_by_prime prime_powers =
  Hash_set.fold prime_powers ~init:Int.Map.empty ~f:(fun map (p, k) ->
    Map.add_multi map ~key:p ~data:k)
  |> Map.map ~f:(List.sort ~compare:Int.compare >> List.to_array)
  |> Map.to_alist
  |> Array.of_list
;;

(* each index is in [0, length] *)
let increment_odometer indices lengths =
  try
    for i = Array.length indices - 1 downto 0 do
      if indices.(i) < lengths.(i)
      then (
        indices.(i) <- indices.(i) + 1;
        raise Exit)
      else indices.(i) <- 0
    done;
    raise Exit
  with
  | Exit -> ()
;;

let iter_prime_power_combinations ~f ~upto =
  let powers = arrange_by_prime (prime_powers_with_hamming_totient ~upto) in
  let lengths = Array.map powers ~f:(fun (_, ks) -> Array.length ks) in
  let odometer = Array.create 0 ~len:(Array.length powers) in
  try
    (* FIXME too many combos *)
    while true do
      Debug.eprint_s [%sexp (odometer : int array)];
      let product = ref 1 in
      for i = 0 to Array.length powers - 1 do
        let p, ks = powers.(i) in
        (* 0 means zeroth power *)
        if odometer.(i) > 0 then product := !product * Int.pow p ks.(odometer.(i) - 1)
      done;
      f !product;
      increment_odometer odometer lengths
    done
  with
  | Exit -> ()
;;

let%expect_test _ =
  iter_prime_power_combinations ~upto:100 ~f:(printf "%d\n");
  [%expect
    {|
    (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
    (0 0 0 0 0 0 0 0 0 0 0 0 0 0 1)
    (0 0 0 0 0 0 0 0 0 0 0 0 0 1 0)
    (0 0 0 0 0 0 0 0 0 0 0 0 0 1 1)
    (0 0 0 0 0 0 0 0 0 0 0 0 1 0 0)
    (0 0 0 0 0 0 0 0 0 0 0 0 1 0 1)
    (0 0 0 0 0 0 0 0 0 0 0 0 1 1 0)
    (0 0 0 0 0 0 0 0 0 0 0 0 1 1 1)
    (0 0 0 0 0 0 0 0 0 0 0 1 0 0 0)
    (0 0 0 0 0 0 0 0 0 0 0 1 0 0 1)
    (0 0 0 0 0 0 0 0 0 0 0 1 0 1 0)
    (0 0 0 0 0 0 0 0 0 0 0 1 0 1 1)
    (0 0 0 0 0 0 0 0 0 0 0 1 1 0 0)
    (0 0 0 0 0 0 0 0 0 0 0 1 1 0 1)
    (0 0 0 0 0 0 0 0 0 0 0 1 1 1 0)
    (0 0 0 0 0 0 0 0 0 0 0 1 1 1 1)
    (0 0 0 0 0 0 0 0 0 0 1 0 0 0 0)
    (0 0 0 0 0 0 0 0 0 0 1 0 0 0 1)
    (0 0 0 0 0 0 0 0 0 0 1 0 0 1 0)
    (0 0 0 0 0 0 0 0 0 0 1 0 0 1 1)
    (0 0 0 0 0 0 0 0 0 0 1 0 1 0 0)
    (0 0 0 0 0 0 0 0 0 0 1 0 1 0 1)
    (0 0 0 0 0 0 0 0 0 0 1 0 1 1 0)
    (0 0 0 0 0 0 0 0 0 0 1 0 1 1 1)
    (0 0 0 0 0 0 0 0 0 0 1 1 0 0 0)
    (0 0 0 0 0 0 0 0 0 0 1 1 0 0 1)
    (0 0 0 0 0 0 0 0 0 0 1 1 0 1 0)
    (0 0 0 0 0 0 0 0 0 0 1 1 0 1 1)
    (0 0 0 0 0 0 0 0 0 0 1 1 1 0 0)
    (0 0 0 0 0 0 0 0 0 0 1 1 1 0 1)
    (0 0 0 0 0 0 0 0 0 0 1 1 1 1 0)
    (0 0 0 0 0 0 0 0 0 0 1 1 1 1 1)
    (0 0 0 0 0 0 0 0 0 1 0 0 0 0 0)
    (0 0 0 0 0 0 0 0 0 1 0 0 0 0 1)
    (0 0 0 0 0 0 0 0 0 1 0 0 0 1 0)
    (0 0 0 0 0 0 0 0 0 1 0 0 0 1 1)
    (0 0 0 0 0 0 0 0 0 1 0 0 1 0 0)
    (0 0 0 0 0 0 0 0 0 1 0 0 1 0 1)
    (0 0 0 0 0 0 0 0 0 1 0 0 1 1 0)
    (0 0 0 0 0 0 0 0 0 1 0 0 1 1 1)
    (0 0 0 0 0 0 0 0 0 1 0 1 0 0 0)
    (0 0 0 0 0 0 0 0 0 1 0 1 0 0 1)
    (0 0 0 0 0 0 0 0 0 1 0 1 0 1 0)
    (0 0 0 0 0 0 0 0 0 1 0 1 0 1 1)
    (0 0 0 0 0 0 0 0 0 1 0 1 1 0 0)
    (0 0 0 0 0 0 0 0 0 1 0 1 1 0 1)
    (0 0 0 0 0 0 0 0 0 1 0 1 1 1 0)
    (0 0 0 0 0 0 0 0 0 1 0 1 1 1 1)
    (0 0 0 0 0 0 0 0 0 1 1 0 0 0 0)
    (0 0 0 0 0 0 0 0 0 1 1 0 0 0 1)
    (0 0 0 0 0 0 0 0 0 1 1 0 0 1 0)
    (0 0 0 0 0 0 0 0 0 1 1 0 0 1 1)
    (0 0 0 0 0 0 0 0 0 1 1 0 1 0 0)
    (0 0 0 0 0 0 0 0 0 1 1 0 1 0 1)
    (0 0 0 0 0 0 0 0 0 1 1 0 1 1 0)
    (0 0 0 0 0 0 0 0 0 1 1 0 1 1 1)
    (0 0 0 0 0 0 0 0 0 1 1 1 0 0 0)
    (0 0 0 0 0 0 0 0 0 1 1 1 0 0 1)
    (0 0 0 0 0 0 0 0 0 1 1 1 0 1 0)
    (0 0 0 0 0 0 0 0 0 1 1 1 0 1 1)
    (0 0 0 0 0 0 0 0 0 1 1 1 1 0 0)
    (0 0 0 0 0 0 0 0 0 1 1 1 1 0 1)
    (0 0 0 0 0 0 0 0 0 1 1 1 1 1 0)
    (0 0 0 0 0 0 0 0 0 1 1 1 1 1 1)
    (0 0 0 0 0 0 0 0 1 0 0 0 0 0 0)
    (0 0 0 0 0 0 0 0 1 0 0 0 0 0 1)
    (0 0 0 0 0 0 0 0 1 0 0 0 0 1 0)
    (0 0 0 0 0 0 0 0 1 0 0 0 0 1 1)
    (0 0 0 0 0 0 0 0 1 0 0 0 1 0 0)
    (0 0 0 0 0 0 0 0 1 0 0 0 1 0 1)
    (0 0 0 0 0 0 0 0 1 0 0 0 1 1 0)
    (0 0 0 0 0 0 0 0 1 0 0 0 1 1 1)
    (0 0 0 0 0 0 0 0 1 0 0 1 0 0 0)
    (0 0 0 0 0 0 0 0 1 0 0 1 0 0 1)
    (0 0 0 0 0 0 0 0 1 0 0 1 0 1 0)
    (0 0 0 0 0 0 0 0 1 0 0 1 0 1 1)
    (0 0 0 0 0 0 0 0 1 0 0 1 1 0 0)
    (0 0 0 0 0 0 0 0 1 0 0 1 1 0 1)
    (0 0 0 0 0 0 0 0 1 0 0 1 1 1 0)
    (0 0 0 0 0 0 0 0 1 0 0 1 1 1 1)
    (0 0 0 0 0 0 0 0 1 0 1 0 0 0 0)
    (0 0 0 0 0 0 0 0 1 0 1 0 0 0 1)
    (0 0 0 0 0 0 0 0 1 0 1 0 0 1 0)
    (0 0 0 0 0 0 0 0 1 0 1 0 0 1 1)
    (0 0 0 0 0 0 0 0 1 0 1 0 1 0 0)
    (0 0 0 0 0 0 0 0 1 0 1 0 1 0 1)
    (0 0 0 0 0 0 0 0 1 0 1 0 1 1 0)
    (0 0 0 0 0 0 0 0 1 0 1 0 1 1 1)
    (0 0 0 0 0 0 0 0 1 0 1 1 0 0 0)
    (0 0 0 0 0 0 0 0 1 0 1 1 0 0 1)
    (0 0 0 0 0 0 0 0 1 0 1 1 0 1 0)
    (0 0 0 0 0 0 0 0 1 0 1 1 0 1 1)
    (0 0 0 0 0 0 0 0 1 0 1 1 1 0 0)
    (0 0 0 0 0 0 0 0 1 0 1 1 1 0 1)
    (0 0 0 0 0 0 0 0 1 0 1 1 1 1 0)
    (0 0 0 0 0 0 0 0 1 0 1 1 1 1 1)
    (0 0 0 0 0 0 0 0 1 1 0 0 0 0 0)
    (0 0 0 0 0 0 0 0 1 1 0 0 0 0 1)
    (0 0 0 0 0 0 0 0 1 1 0 0 0 1 0)
    (0 0 0 0 0 0 0 0 1 1 0 0 0 1 1)
    1
    101
    97
    9797
    73
    7373
    7081
    715181
    61
    6161
    5917
    597617
    4453
    449753
    431941
    43626041
    41
    4141
    3977
    401677
    2993
    302293
    290321
    29322421
    2501
    252601
    242597
    24502297
    182573
    18439873
    17709581
    1788667681
    37
    3737
    3589
    362489
    2701
    272801
    261997
    26461697
    2257
    227957
    218929
    22111829
    164761
    16640861
    15981817
    1614163517
    1517
    153217
    147149
    14862049
    110741
    11184841
    10741877
    1084929577
    92537
    9346237
    8976089
    906584989
    6755201
    682275301
    655254497
    66180704197
    31
    3131
    3007
    303707
    2263
    228563
    219511
    22170611
    1891
    190991
    183427
    18526127
    138043
    13942343
    13390171
    1352407271
    1271
    128371
    123287
    12451987
    92783
    9371083
    8999951
    908995051
    77531
    7830631
    7520507
    759571207
    5659763
    571636063
    548997011
    55448698111
    1147
    115847
    111259
    11237159 |}]
;;

let _modulo = 1 lsl 32
let limit = 1_000_000_000_000

let main () =
  let count =
    hamming
    |> Stream.fold_until ~init:0 ~finish:Fn.id ~f:(fun count elt ->
      if elt > limit then Stop count else Continue (count + 1))
  in
  printf "%d elements under %d\n" count limit
;;

include (val Solution.make ~problem:(Number 516) ~main)
